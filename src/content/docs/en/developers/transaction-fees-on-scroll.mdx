---
section: developers
date: Last Modified
title: "Transaction Fees on Scroll"
lang: "en"
permalink: "developers/transaction-fees-on-scroll"
whatsnext: { "Contract Deployment Tutorial": "/developers/guides/contract-deployment-tutorial/" }
excerpt: "Understand how L1 and L2 transaction fees work on Scroll "
---

import Aside from "../../../../components/Aside.astro"

## Overview

Scroll Sepolia Testnet fees are notably lower than on its supporting layer. Being an L2 rollup also means that the total transaction cost depends on the L1's costs, since, to leverage Ethereum's security, data and proofs have to be stored and computed on the L1.

For users and developers, transaction fees on Scroll work similarly to those on Ethereum mainnet, and all existing tools, wallets, and code should be expected to work the same.

Behind the scenes, however, Scroll Sepolia introduces some new dimensions to transaction fee calculation. The final cost of a transaction is constructed from several parts:

- **L2 fee**
  - Calculated in the same manner as on the L1, equaling `gas_price * gas_used`
- **L1 fee**
  - This additional fee covers sending data to L1 for data availability. Transactions initiated on the L1 do not pay this fee.
  - It is calculated based on the size of the transaction's calldata
  - ETH is automatically deducted from the user’s balance on Scroll for the fee

At a high level, the **L2 fee** is the cost of executing your transaction on the L2 sequencer, and the **L1 fee** is the cost of committing that transaction onto L1.

In short, `totalTxFee = l2Fee + l1Fee`, all denominated in ETH, the native gas token for the Scroll network.

<Aside type="note" title="Where are transaction fees sent?">
All tx fees are collected into the `L2ScrollFeeVault` contract balance. This contract also tracks the amount we’ve historically withdrawn to L1 using `totalProcessed()(uint256)`.

The block producer receives no direct reward, and the `COINBASE` opcode returns the fee vault address.

</Aside>

## L2 Fee

Transactions on Scroll, like on Ethereum, must pay the cost of executing their computations and storing the data they produce.

### Calculating the Execution Fee

In short, it is calculated very simply:

```javascript
l2TransactionExecutionFee = l2TransactionGasUsed * l2TransactionGasPrice
```

The total fee depends on what the transaction does (`l2TransactionGasUsed`) as well as the current market conditions (`l2TransactionGasPrice`). Users set the gas price, and the "gas used" is assessed by calling the `estimateGas` endpoint on a Scroll node.

In other words, the execution fee is calculated precisely like pre-[EIP1559](https://eips.ethereum.org/EIPS/eip-1559) Ethereum.

## L1 Fee

Every transaction's calldata must be committed to Ethereum, which incurs an additional transaction fee, referred to as the "L1 Fee". Without doing this, Scroll couldn't be reconstructed from only L1 data.

Transactions aren't committed 1-by-1 -- they are collected in batches of blocks (and blocks of transactions). The cost of an individual transaction is computed based on the zeros and non-zero bytes in its payload.

### Calculating the L1 Data Fee

The data fee is based on multiple factors:

- The bytes which are `zeros` and `nonzeros` of an RLP-encoded transaction with Signature
- `l1BaseFee` - Current base fee on the L1
- `overhead` - Additional gas overhead of a data commitment transaction
- `scalingFactor` - A scaling factor used to account for price spikes
- `PRECISION` - A constant used to scale the final fee

Then, the final formula would be

```javascript
l1Gas = zeros * 4 + (nonzeros + 4) * 16
l1GasFee = ((l1Gas + overhead) * l1BaseFee * scalar) / PRECISION
```

{/* TODO revise starting here */}

### What happens if gas fluctuates on L1?

If a gas spike happens on the L1 after the transaction has been processed by the sequencer, it doesn’t affect what the user pays.

The transaction execution happens in a few steps:

1. Creation of transaction _(Client side)_
2. Emitting of the transaction _(Client side)_
3. Processing of the transaction _(Sequencer)_
4. Committing of the transaction _(Sequencer)_

Everything after the second step is the responsibility of the sequencer. Should the L1 gas cost increase (or decrease) between the processing and actual committing of a transaction, the user shouldn't be affected, and the sequencer will pay for all cost fluctuations.

## Gas Oracle

Scroll Sepolia has a pre-deployed contract `L1GasPriceOracle` (contract address [`0x5300000000000000000000000000000000000002`](https://sepolia-blockscout.scroll.io/address/0x5300000000000000000000000000000000000002)) used to estimate the L1 gas fee given raw transaction data. This is a **push oracle**, updated by a relayer run by Scroll.
{/* TODO: Double check this address is used for Sepolia */}

It stores the L1 base fee gas price and provides a public API, which can be used to estimate the total transaction fee for some L2 transactions.

### How does it work?

The L1 fee calculation works as follows.

1. Read three fields `l1BaseFee`, `overhead`, `scalar` from the `L1GasPriceOracle` contract. The slots for these fields in the contract are

| Field     | Slot |
| --------- | ---- |
| l1BaseFee | 1    |
| overhead  | 2    |
| scalar    | 3    |

2. Count the number of zero bytes and non-zero bytes from the transaction callData.
3. Calculate the sumL1 data fee (`PRECISION = 1e9`)

#### What does the commit tx consist of?

Encoding of a transaction in the commit tx \[length] \[RLP-encoded transaction with signature] consists of two parts:

1. The sum of zero bytes and non-zero bytes in the RLP-encoded transaction without signature&#x20;
2. Additional 74 bytes&#x20;
   - 4 bytes: the length prefix of transaction data&#x20;
   - 1 byte: RLP prefix for V&#x20;
   - 3 bytes: V&#x20;
   - 1 byte: RLP prefix for R&#x20;
   - 32 bytes: R&#x20;
   - 1 byte: RLP prefix for S&#x20;
   - 32 bytes: S

### API

#### overhead

```solidity
function overhead() external view returns (uint256);
```

Returns the current L1 fee overhead

#### scalar

```solidity
function scalar() external view returns (uint256);
```

Returns the current l1 fee scalar

#### l1BaseFee

```solidity
function l1BaseFee() external view returns (uint256);
```

Returns the latest known l1 base fee

#### getL1Fee

```solidity
function getL1Fee(bytes memory data) external view returns (uint256);
```

Computes the L1 portion of the fee based on the size of the RLP encoded input transaction, the current L1 base fee, and the various dynamic parameters.

**Returns:** L1 fee that should be paid for the transaction

| Parameter | Description                                                        |
| --------- | ------------------------------------------------------------------ |
| data      | data Unsigned fully RLP-encoded transaction to get the L1 fee for. |

#### getL1GasUsed

```solidity
function getL1GasUsed(bytes memory data) external view returns (uint256);
```

Computes the amount of L1 gas used for a transaction. Adds the overhead which represents the per-transaction gas overhead of posting the transaction and state roots to L1. Adds 74 bytes of padding to account for the fact that the input does not have a signature.

**Returns:** Amount of L1 gas used to publish the transaction.

| Parameter | Description                                                        |
| --------- | ------------------------------------------------------------------ |
| data      | data Unsigned fully RLP-encoded transaction to get the L1 fee for. |

## Future Roadmap

Currently, the computation required for proof generation is done and subsidized by Scroll.

In the future, the prover network will be decentralized and require the incorporation of rewards to be earned by the protocol’s actors for the system to be sustainable and scalable.

The final gas cost will include the cost of proof generation, which, as the protocol becomes further optimized, will become cheaper as they're shared between all transactions on the network.
